点击<canvas id=c>
  <script>
    // EXPI by Mathieu 'p01' Henri + Veikko 'pestis' Sariola
    // 1kb intro for Assembly 2023
    //
    // EXPI lives in the Brotli dictionary. RIP Jpeg decoder. RIP Compo live stream.
    //
    // This file compressess down 1024 bytes using a custom made packer/minifier + Brotli-11
    onclick = d => {
      b = c.getContext`2d`;
      S = Math.sin;
      min = Math.min;
      P = Math.PI;
      A = new AudioContext;
      // A single channel buffer with chunks of 2048 samples (it must be a power of 2), and 1024 can be tight
      // the sampleFrequency depends on the browser and audio drivers, but it's typically 44100 or 48000Hz
      a = A.createScriptProcessor(2048, onclick = delayIndex = T = t = 0, 1);
      a.connect(A.destination);
      // abuse the audioprocess to update the audio buffer, and the viusals
      // This gives a funky framerate due to the number of samples (1024, 2048, ...) and sampleRate (44100, 48000)
      // But that's what I've used for a while. It works fine and no one complained :p
      a.onaudioprocess = d => {
        // clear and reset the canvas
        c.width = 1024;
        c.height = 576;
        d = d.outputBuffer.getChannelData(0);
        M = min(1, .1 + S(min(1, t / 128) * P) * 4);

        // 🎹🎺📻🐉 Sound Synth
        for (i = 0; i < 2048; i++) {
          b[i] = syncsSum = 0; // b is the canvas, but we reuse it as an array to store the envelopes of music channels for syncs
          part = t / 16;
          y = A[++delayIndex] || 0; // t = signal output. A is the AudioContext, but we reuse it as an array to store the delay buffer
          a = min(part, 7) & 7;

          // 🎻 The additive synthesizer
          for (j = "20020002"[a]; j < "41446664"[a]; j++) { // only some of the channels are active, depending on the part
            r = part * (1 << 5 - j); // r = row within pattern
            v = r % 1; // v = position within row
            r = part * (132 << j) * P * [10, 0, 15, 10, 18, 10, 15, 20][r & 7]; // r = frequency
            syncsSum += b[j] = v = r && 3 ** -(.006 / v + j / 2 + v * 2); // b[j] = v = channel envelope
            for (f = 1; f < 7; f++)
              y += S(part * f / 8) * S(r * f) * v / 3 // S(r * f) is the "partial", S(part * f / 8) is the slowly changing weight of the partial
          }

          // 🥁 Drums
          r = t * 8 + 1; // r = row within pattern
          v = r % 1; // v = position within row
          j = (r & 15) ** "14212421"[a] % "19939971"[a]; // j = what drum to play, 0 = no drum 1 = kick 2+ = noisy snare/hihats
          r = 3 ** -(.006 / v + j / 4 + v * j); // r = envelope
          syncsSum += b6 = j == 1 && r; // store the kick drum envelope to b6 for syncs
          y += S(256 * j ** 16 * v ** .1) * r; // add the kick drum to signal output


          A[delayIndex %= A.sampleRate / 2] = y / 3; // store the signal to the delay buffer
          d[i] = y * .6 * M; // store the signal into "d" the output buffer and move "t" forward
          t += 1 / A.sampleRate
        }

        // ⚞⚟ Horizon
        b.strokeStyle = "#fc9";
        b.translate(512, 288);
        for (i = r = 8 + part; i < 64; i++) {
          b.beginPath();
          b.lineWidth = min(part, 1) ** 8 * r / 1024;
          b.ellipse(0, 0, (t & 32) * r + r, r, 0, 0, P * 2);
          b.stroke();
          r += r / 8
        }

        zzzz = min(4, t / 4) + syncsSum ** 4 * 2;

        // 🥨 Twister
        for (i = 0; i < 2; i += 1 / 256) {
          a = t + S(i * P + S(i * P + S(t)));
          b.rotate(P / 256);
          for (v = j = 0; j <= 4; j++) {
            f = v;
            y = S(a + P / 2 * j);
            v = min(part - 1, M) * (t / 4 % 2 + 1) * (32 + zzzz + 8 * S(a + P * S(t / 3)) - min(-M, 8 * S(a) - 8 * b6) * y);
            if (v * j > 0 & v > f) {
              b.fillStyle = `hsl(${i * 180 + j * 90},50%,${48 + 48 * y}%`;
              b.fillRect(0, f, 2, v - f)
            }
          }
          b.fillStyle = b.shadowColor = "#fc9";
          b.fillRect(0, S(i * 64) * (512 + t), 2, 2) // stars
        }

        // 🌁 Blur the twister
        b.filter = "blur(10px";
        b.globalAlpha = .2;
        r = 1024;
        b.drawImage(c, -r, -r / 2, r * 2, r);
        b.globalAlpha = .1;
        r = r * 4;
        b.drawImage(c, -r, -r / 2, r * 2, r);
        b.filter = "none";

        // 🐁🔠 Tiny EXPI text
        b.globalAlpha = b[1] + b[2];
        for (i = 0; i < 16; i++)
          b.fillText("EXPI"[t / 2 & 3], i * 200 - 512, 0);

        // ©️ End credits
        b.globalAlpha = min(1, t / 128) ** 32;
        b.fillText("p01+pestis", -t, 8);
        b.font = "900 30px sans-serif";
        b.fillText("EXPI", -t, 0);

        // 🐘🔠 Big EXPI text
        b.globalAlpha = b[4];
        b.font = "900 250px sans-serif";
        for (i = 0; i < 16; i++)
          b.fillText("EXPIEXPI", i * 200 - t * 16 - 800, i * 200 - t * 16);

        // 📺 Grab jpeg
        if (t > T)
          T++,
            jpg = c.toDataURL("image/jpeg").split("");

        // ☀️ Sun
        b.beginPath(
          b.shadowBlur = 30);
        b.arc(0, 0, 8 * zzzz, b.globalAlpha = 1, 8);
        b.fill();

        // 💥 Glitch the jpg
        if (part > 3 & syncsSum > .1)
          jpg[Math.random() * jpg.length | 0] = 0;

        // 🖥️⚫⚪ Display the jpg, perhaps in grayscale
        c.style = `position:fixed;top:0px;left:0px; height:100%;width:100%;filter:grayscale(${(part - 1) % 3 >> 1}); background:radial-gradient(#303,#0004),url(${jpg.join("")})50%/90%`
      }
    }
  </script>